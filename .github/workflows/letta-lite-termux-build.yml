name: 仅输出 Termux 独立可执行文件（纯净版）
on: 
  workflow_dispatch:  # 仅手动触发，避免误触发
  push:
    branches: ['main']
    paths: 
      - "examples/node-cli/**"
      - "src/**"
      - "bindings/node/**"

jobs:
  build-termux-pure:
    runs-on: ubuntu-latest
    env:
      OPENSSL_VERSION: 1.1.1w
      OPENSSL_SRC_DIR: ${{ github.workspace }}/openssl-src
      OPENSSL_INSTALL_DIR: ${{ github.workspace }}/openssl-install
      TARGET_ARCH: aarch64-linux-android
      ANDROID_API_LEVEL: 24
      NODE_VERSION: 18.20.3
      CLI_OUTPUT_NAME: letta-termux-cli  # 仅保留这个核心文件

    steps:
      # 步骤1：拉取代码
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 1

      # 步骤2：安装最小化依赖
      - name: Install minimal dependencies
        run: |
          sudo apt-get update --fix-missing
          sudo apt-get install -y \
            rustc cargo git make wget curl perl pkg-config binutils gcc g++
          rustc --version
          cargo --version

      # 步骤3：安装 Android NDK（仅交叉编译用）
      - name: Install Android NDK
        uses: android-actions/setup-android@v3
        with:
          accept-android-sdk-licenses: true
          packages: "ndk;27.3.13750724"

      # 步骤4：查找 NDK 路径
      - name: Find NDK path
        run: |
          NDK_PATH=$(find /usr/local/lib/android/sdk/ndk -maxdepth 1 -type d | grep -E "27.3.13750724$")
          echo "NDK_TOOLCHAIN_BIN=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin" >> $GITHUB_ENV
          echo "NDK_SYSROOT=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/sysroot" >> $GITHUB_ENV

      # 步骤5：编译 OpenSSL
      - name: Build OpenSSL
        run: |
          mkdir -p "${{ env.OPENSSL_SRC_DIR }}" "${{ env.OPENSSL_INSTALL_DIR }}"
          cd "${{ env.OPENSSL_SRC_DIR }}" || exit 1
          wget -q --no-check-certificate "https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz"
          tar -xvzf "openssl-${{ env.OPENSSL_VERSION }}.tar.gz" --strip-components=1 > /dev/null 2>&1

          export CC="${{ env.NDK_TOOLCHAIN_BIN }}/aarch64-linux-android${{ env.ANDROID_API_LEVEL }}-clang"
          export CXX="${{ env.NDK_TOOLCHAIN_BIN }}/aarch64-linux-android${{ env.ANDROID_API_LEVEL }}-clang++"
          export AR="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ar"
          export RANLIB="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ranlib"
          export LD="${{ env.NDK_TOOLCHAIN_BIN }}/ld.lld"
          export PATH="${{ env.NDK_TOOLCHAIN_BIN }}:$PATH"

          ./Configure android-arm64 no-shared no-asm no-zlib \
            --prefix="${{ env.OPENSSL_INSTALL_DIR }}" \
            --sysroot="${{ env.NDK_SYSROOT }}" \
            -fPIC -march=armv8-a -O2

          make -j$(nproc) > /dev/null 2>&1 || { echo "❌ OpenSSL build failed"; exit 1; }
          make install_sw > /dev/null 2>&1 || { echo "❌ OpenSSL install failed"; exit 1; }

      # 步骤6：配置 Rust
      - name: Configure Rust
        run: |
          rustup toolchain install stable --force
          rustup target add ${{ env.TARGET_ARCH }}

      # 步骤7：编译 Rust SO 库（仅保留 ARM64 版本，删除其他）
      - name: Build Rust SO library
        run: |
          cd bindings/node || { echo "❌ bindings/node not found"; exit 1; }
          export OPENSSL_DIR=${{ env.OPENSSL_INSTALL_DIR }}
          export TARGET=${{ env.TARGET_ARCH }}
          export NDK_TOOLCHAIN_BIN=${{ env.NDK_TOOLCHAIN_BIN }}
          export NDK_SYSROOT=${{ env.NDK_SYSROOT }}

          # 编译仅 ARM64 版本，不生成其他架构
          cargo build --release --target ${{ env.TARGET_ARCH }}
          SO_PATH="./target/${{ env.TARGET_ARCH }}/release/libletta_lite_node.so"
          if [ ! -f "$SO_PATH" ]; then echo "❌ SO library not found"; exit 1; fi

          # 复制 SO 库到 NodeCLI 目录，同时删除其他冗余文件
          mkdir -p ../examples/node-cli/native/lib
          cp "$SO_PATH" ../examples/node-cli/native/lib/
          # 删除 Rust 编译残留的其他文件（头文件、其他架构产物等）
          rm -rf ./target/*/debug/ ./target/*/release/*.h ./target/*/release/*.rlib ./target/*/release/*.so.dSYM

      # 步骤8：编译 JS 代码（清理 npm 残留）
      - name: Build JS code
        working-directory: ./examples/node-cli
        run: |
          nvm install ${{ env.NODE_VERSION }} && nvm use ${{ env.NODE_VERSION }}
          npm install --silent  # 静默安装，减少 log 输出
          npm install -g typescript pkg --silent
          
          # 生成 TS 配置
          if [ ! -f "tsconfig.json" ]; then
            echo '{
              "compilerOptions": {
                "target": "ES2020", "module": "CommonJS", "outDir": "./dist", "rootDir": "./src",
                "strict": true, "esModuleInterop": true, "skipLibCheck": true
              },
              "include": ["src/**/*"], "exclude": ["node_modules"]
            }' > tsconfig.json
          fi
          
          tsc --project tsconfig.json --quiet  # 静默编译，减少 log
          # 删除 npm 残留的 log、临时文件
          rm -rf npm-debug.log yarn-debug.log yarn-error.log .npm .yarn

      # 步骤9：打包 Termux 独立文件（清理冗余 SO 和 AAR）
      - name: Package Termux executable
        working-directory: ./examples/node-cli
        run: |
          ENTRY_FILE="./dist/index.js"
          if [ ! -f "$ENTRY_FILE" ]; then echo "❌ Entry file not found"; exit 1; fi

          # 打包仅 ARM64 独立文件
          pkg "$ENTRY_FILE" \
            --targets node${{ env.NODE_VERSION }}-android-arm64 \
            --output ${{ env.CLI_OUTPUT_NAME }} \
            --assets ./native/lib
          
          # 清理 ELF 适配 Termux
          wget -q https://github.com/termux/termux-elf-cleaner/releases/latest/download/termux-elf-cleaner-x86_64-linux
          chmod +x termux-elf-cleaner-x86_64-linux
          ./termux-elf-cleaner-x86_64-linux --api-level ${{ env.ANDROID_API_LEVEL }} ./${{ env.CLI_OUTPUT_NAME }}

          chmod +x ./${{ env.CLI_OUTPUT_NAME }}
          # 强制删除所有冗余产物（AAR、额外 SO、头文件、log）
          rm -rf ./native/lib/*.so ./build/ ./dist/ ./node_modules/ ./*.aar ./*.h ./*.log termux-elf-cleaner-x86_64-linux

      # 步骤10：验证仅保留核心文件
      - name: Verify pure output
        working-directory: ./examples/node-cli
        run: |
          echo "当前目录文件："
          ls -l
          # 检查是否仅存在核心文件
          if [ $(ls -1 | wc -l) -ne 1 ] || [ ! -f "./${{ env.CLI_OUTPUT_NAME }}" ]; then
            echo "❌ 存在冗余文件！"
            exit 1
          fi
          echo "✅ 仅保留核心文件，体积：$(du -sh ./${{ env.CLI_OUTPUT_NAME }} | awk '{print $1}')"

      # 步骤11：上传仅核心文件
      - name: Upload pure Termux executable
        uses: actions/upload-artifact@v4
        with:
          name: termux-letta-pure-cli
          path: ./examples/node-cli/${{ env.CLI_OUTPUT_NAME }}
          retention-days: 30

      # 步骤12：发布到 Releases（仅核心文件）
      - name: Release pure executable
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          name: Termux 纯净版可执行文件（ARM64）
          tag_name: termux-pure-cli-${{ github.run_id }}
          body: |
            ## 纯净版！仅 1 个文件，直接运行
            - 适配：ARM64 安卓手机（Termux 环境）
            - 无冗余：无 AAR、无多余 SO、无 log、无 header 文件
            - 使用：
              1. 下载 ${{ env.CLI_OUTPUT_NAME }}
              2. Termux 执行：chmod +x ./${{ env.CLI_OUTPUT_NAME }}
              3. 运行：./${{ env.CLI_OUTPUT_NAME }}
          files: ./examples/node-cli/${{ env.CLI_OUTPUT_NAME }}
          draft: false
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
