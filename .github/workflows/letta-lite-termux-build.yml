name: Termux命令窗独立文件（SO+JS缝合版）
on: 
  workflow_dispatch:  # 仅手动触发，避免干扰
  push:
    branches: ['main']
    paths: 
      - "examples/node-cli/**"
      - "src/**"
      - "bindings/node/**"

jobs:
  build-termux-stitch:
    runs-on: ubuntu-latest
    env:
      OPENSSL_VERSION: 1.1.1w
      OPENSSL_SRC_DIR: ${{ github.workspace }}/openssl-src
      OPENSSL_INSTALL_DIR: ${{ github.workspace }}/openssl-install
      TARGET_ARCH: aarch64-linux-android
      ANDROID_API_LEVEL: 24
      NODE_VERSION: 18.20.3
      CLI_OUTPUT_NAME: letta-termux-cli  # 最终缝合后的独立文件
      # 关键：禁用Android编译脚本的环境变量（防止误触发）
      DISABLE_ANDROID_BUILD: true

    steps:
      # 步骤1：拉取代码（含子模块）
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 1

      # 步骤2：安装最小化依赖（删除Gradle/Java等Android相关工具）
      - name: Install minimal dependencies
        run: |
          sudo apt-get update --fix-missing
          sudo apt-get install -y \
            rustc cargo git make wget curl perl pkg-config binutils gcc g++
          # 卸载可能存在的Android相关工具，避免干扰
          sudo apt-get remove -y openjdk-* gradle android-sdk* 2>/dev/null
          rustc --version
          cargo --version

      # 步骤3：安装Android NDK（仅用于交叉编译SO库，不生成AAR）
      - name: Install Android NDK（仅交叉编译用）
        uses: android-actions/setup-android@v3
        with:
          accept-android-sdk-licenses: true
          packages: "ndk;27.3.13750724"

      # 步骤4：查找NDK路径
      - name: Find NDK path
        run: |
          NDK_PATH=$(find /usr/local/lib/android/sdk/ndk -maxdepth 1 -type d | grep -E "27.3.13750724$")
          echo "NDK_TOOLCHAIN_BIN=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin" >> $GITHUB_ENV
          echo "NDK_SYSROOT=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/sysroot" >> $GITHUB_ENV

      # 步骤5：编译OpenSSL（静态编译，供Rust SO库使用）
      - name: Build OpenSSL
        run: |
          mkdir -p "${{ env.OPENSSL_SRC_DIR }}" "${{ env.OPENSSL_INSTALL_DIR }}"
          cd "${{ env.OPENSSL_SRC_DIR }}" || exit 1
          wget -q --no-check-certificate "https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz"
          tar -xvzf "openssl-${{ env.OPENSSL_VERSION }}.tar.gz" --strip-components=1 > /dev/null 2>&1

          export CC="${{ env.NDK_TOOLCHAIN_BIN }}/aarch64-linux-android${{ env.ANDROID_API_LEVEL }}-clang"
          export CXX="${{ env.NDK_TOOLCHAIN_BIN }}/aarch64-linux-android${{ env.ANDROID_API_LEVEL }}-clang++"
          export AR="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ar"
          export RANLIB="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ranlib"
          export LD="${{ env.NDK_TOOLCHAIN_BIN }}/ld.lld"
          export PATH="${{ env.NDK_TOOLCHAIN_BIN }}:$PATH"

          ./Configure android-arm64 no-shared no-asm no-zlib \
            --prefix="${{ env.OPENSSL_INSTALL_DIR }}" \
            --sysroot="${{ env.NDK_SYSROOT }}" \
            -fPIC -march=armv8-a -O2

          make -j$(nproc) > /dev/null 2>&1 || { echo "❌ OpenSSL build failed"; exit 1; }
          make install_sw > /dev/null 2>&1 || { echo "❌ OpenSSL install failed"; exit 1; }

      # 步骤6：配置Rust（交叉编译ARM64 SO库）
      - name: Configure Rust
        run: |
          rustup toolchain install stable --force
          rustup target add ${{ env.TARGET_ARCH }}
          # 设置Rust编译参数，避免生成JNI或AAR相关产物
          echo 'CARGO_BUILD_TARGET=${{ env.TARGET_ARCH }}' >> $GITHUB_ENV
          echo 'OPENSSL_DIR=${{ env.OPENSSL_INSTALL_DIR }}' >> $GITHUB_ENV

      # 步骤7：编译Rust核心SO库（仅生成libletta_lite_node.so，无JNI/AAR）
      - name: Build Rust SO library（仅Node.js绑定）
        run: |
          cd bindings/node || { echo "❌ bindings/node not found"; exit 1; }
          # 明确指定仅编译Node.js绑定的SO库，禁用JNI/AAR编译
          cargo build --release --target ${{ env.TARGET_ARCH }} --no-default-features --features "nodejs"
          
          # 验证SO库是否生成（仅保留Node.js绑定的SO库，无JNI）
          SO_PATH="./target/${{ env.TARGET_ARCH }}/release/libletta_lite_node.so"
          if [ ! -f "$SO_PATH" ]; then
            echo "❌ Node.js绑定SO库未生成！当前目录产物："
            ls -l ./target/${{ env.TARGET_ARCH }}/release/
            exit 1
          fi
          echo "✅ Rust SO库编译完成：$SO_PATH"

          # 复制SO库到NodeCLI目录，供打包使用
          mkdir -p ../examples/node-cli/native/lib
          cp "$SO_PATH" ../examples/node-cli/native/lib/
          echo "✅ SO库已复制到NodeCLI目录"

      # 步骤8：安装Node.js并编译命令窗JS代码
      - name: Build NodeCLI（命令窗代码）
        working-directory: ./examples/node-cli
        run: |
          # 安装Node.js 18（适配Termux）
          nvm install ${{ env.NODE_VERSION }} && nvm use ${{ env.NODE_VERSION }}
          node -v && npm -v

          # 安装NodeCLI依赖（含letta-lite Node.js绑定）
          npm install --silent
          # 安装打包工具
          npm install -g typescript pkg --silent

          # 生成TS配置文件（确保编译成功）
          if [ ! -f "tsconfig.json" ]; then
            echo '{
              "compilerOptions": {
                "target": "ES2020", "module": "CommonJS", "outDir": "./dist", "rootDir": "./src",
                "strict": true, "esModuleInterop": true, "skipLibCheck": true
              },
              "include": ["src/**/*"], "exclude": ["node_modules"]
            }' > tsconfig.json
          fi

          # 编译TS到JS（命令窗核心逻辑）
          tsc --project tsconfig.json --quiet || { echo "❌ JS编译失败"; exit 1; }
          echo "✅ NodeCLI命令窗代码编译完成"

          # 验证入口文件是否存在
          ENTRY_FILE="./dist/index.js"
          if [ ! -f "$ENTRY_FILE" ]; then
            echo "❌ 命令窗入口文件未找到！"
            ls -l ./dist
            exit 1
          fi

      # 步骤9：缝合SO库+命令窗→Termux独立文件（核心步骤）
      - name: 缝合SO库与命令窗（生成独立文件）
        working-directory: ./examples/node-cli
        run: |
          ENTRY_FILE="./dist/index.js"
          SO_LIB="./native/lib/libletta_lite_node.so"

          # 验证依赖文件存在
          if [ ! -f "$ENTRY_FILE" ] || [ ! -f "$SO_LIB" ]; then
            echo "❌ 缝合依赖缺失！"
            ls -l ./dist && ls -l ./native/lib
            exit 1
          fi

          # 用pkg缝合：Node.js运行时 + JS命令窗 + Rust SO库 → 独立ELF文件
          pkg "$ENTRY_FILE" \
            --targets node${{ env.NODE_VERSION }}-android-arm64 \
            --output ${{ env.CLI_OUTPUT_NAME }} \
            --assets "$SO_LIB" \
            --no-bytecode --public-packages "*" --public

          # 用Termux ELF清理工具适配权限
          wget -q https://github.com/termux/termux-elf-cleaner/releases/latest/download/termux-elf-cleaner-x86_64-linux
          chmod +x termux-elf-cleaner-x86_64-linux
          ./termux-elf-cleaner-x86_64-linux --api-level ${{ env.ANDROID_API_LEVEL }} ./${{ env.CLI_OUTPUT_NAME }}

          # 验证缝合产物
          if [ ! -f "./${{ env.CLI_OUTPUT_NAME }}" ]; then
            echo "❌ 缝合失败！未生成独立文件"
            exit 1
          fi

          # 赋予执行权限
          chmod +x ./${{ env.CLI_OUTPUT_NAME }}
          echo "✅ 缝合成功！Termux独立文件生成：$(du -sh ./${{ env.CLI_OUTPUT_NAME }} | awk '{print $1}')"

      # 步骤10：清理所有冗余产物（只留缝合后的独立文件）
      - name: 清理冗余（仅保留核心文件）
        working-directory: ./examples/node-cli
        run: |
          # 删除所有中间产物
          rm -rf ./dist ./node_modules ./native ./tsconfig.json \
            termux-elf-cleaner-x86_64-linux npm-debug.log

          # 验证仅保留核心文件
          echo "当前目录剩余文件："
          ls -l
          if [ $(ls -1 | wc -l) -ne 1 ] || [ ! -f "./${{ env.CLI_OUTPUT_NAME }}" ]; then
            echo "❌ 仍存在冗余文件！"
            exit 1
          fi
          echo "✅ 清理完成，仅保留Termux独立文件"

      # 步骤11：上传缝合后的核心文件
      - name: 上传Termux独立文件
        uses: actions/upload-artifact@v4
        with:
          name: termux-letta-cli-stitch
          path: ./examples/node-cli/${{ env.CLI_OUTPUT_NAME }}
          retention-days: 30

      # 步骤12：发布到Releases（仅核心缝合文件）
      - name: 发布Termux独立文件
        if: success()
        uses: softprops/action-gh-release@v2
        with:
          name: Termux命令窗独立文件（SO+JS缝合版）
          tag_name: termux-stitch-cli-${{ github.run_id }}
          body: |
            ## 已完成SO库+命令窗缝合！直接运行！
            - 适配：ARM64安卓手机（Termux环境）
            - 内容：内置Node.js运行时 + Letta-Lite SO库 + 命令窗交互逻辑
            - 使用步骤：
              1. 下载 ${{ env.CLI_OUTPUT_NAME }}
              2. Termux执行：chmod +x ./${{ env.CLI_OUTPUT_NAME }}
              3. 运行：./${{ env.CLI_OUTPUT_NAME }}
            - 无冗余：仅1个文件，无需任何额外依赖
          files: ./examples/node-cli/${{ env.CLI_OUTPUT_NAME }}
          draft: false
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
