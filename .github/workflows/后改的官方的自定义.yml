name: lettalite作者方案：Rust安卓编译（profile mobile版）
on: [workflow_dispatch]
jobs:
  build-android:
    runs-on: ubuntu-latest
    env:
      ANDROID_NDK_VERSION: 27.3.13750724
      ANDROID_API_LEVEL: 24
      TARGET_ARCH: aarch64-linux-android
      OPENSSL_VERSION: 1.1.1w
      OPENSSL_SRC_DIR: ${{ github.workspace }}/openssl-src
      OPENSSL_INSTALL_DIR: ${{ github.workspace }}/openssl-install
      OUTPUT_DIR: ${{ github.workspace }}/target/android
      CORE_DIR: "core"  # 子包目录（正确）
      CORE_PACKAGE_NAME: "letta-core"  # 子包名（正确）

    steps:
      - name: 拉取letta-lite源码
        uses: actions/checkout@v4

      - name: 安装基础依赖
        run: |
          sudo apt-get update && sudo apt-get install -y \
            coreutils pkg-config make perl wget curl gcc cmake \
            libssl-dev zlib1g-dev

      # ===================== 修复：提取外部API（兼容所有环境） =====================
      - name: 提取能从.so调用的外部API（编译前）
        run: |
          cd ${{ env.CORE_DIR }}
          echo -e "\n========================================"
          echo "📋 编译前：能从.so调用的外部API（仅暴露这些）"
          echo "========================================"
          echo "🔍 筛选规则：带 #[no_mangle] 或 extern \"C\" 标记的函数"

          # 简化版提取：不用复杂正则，兼容所有awk版本
          EXTERNAL_APIS=""
          while IFS= read -r -d '' file_content; do
            # 提取文件名
            filename=$(echo "$file_content" | grep -oE '^[^:]+' | head -n1)
            # 提取注释
            docs=$(echo "$file_content" | grep -oE '/// .*' | sed 's/\/\/\/ //g' | tr '\n' ' ' || echo "无说明文档")
            # 提取暴露标记
            if echo "$file_content" | grep -q '#\[no_mangle\]'; then
              flag="#[no_mangle]（宏自动标记）"
            elif echo "$file_content" | grep -q 'extern "C"'; then
              flag="extern \"C\"（手动标记）"
            else
              continue
            fi
            # 提取函数签名（简化：fn 函数名(...)）
            func_line=$(echo "$file_content" | grep -oE 'fn [a-zA-Z_][a-zA-Z0-9_]*\([^)]*\)')
            if [ -z "$func_line" ]; then
              continue
            fi
            # 分割函数名和参数
            func_name=$(echo "$func_line" | sed 's/fn //; s/(.*//')
            params=$(echo "$func_line" | sed 's/.*(//; s/)//' | sed 's/[ \t]+/ /g')
            # 提取返回值
            ret_type=$(echo "$file_content" | grep -oE '-> [^;]+' | sed 's/-> //' | sed 's/[ \t]+//g' || echo "无返回值")
            # 拼接结果
            EXTERNAL_APIS+="🔍 函数名：$func_name\n   所在文件：$filename\n   参数：$params\n   返回值：$ret_type\n   说明：$docs\n   暴露标记：$flag\n\n"
          done < <(grep -rniH --null -A 3 -B 3 -E '#\[no_mangle\]|extern "C"' src/)

          # 输出结果
          if [ -z "$EXTERNAL_APIS" ]; then
            echo -e "\n⚠️  未找到任何外部API！请检查："
            echo "   - core/src/lib.rs是否用 export_letta_api!() 标记了函数？"
            echo "   - 函数是否带 #[no_mangle] 或 extern \"C\" 标记？"
          else
            echo -e "\n【已标记的外部API（共$(echo -e "$EXTERNAL_APIS" | grep -c "🔍 函数名：")个）】"
            echo -e "$EXTERNAL_APIS"
          fi

          # 统计信息
          TOTAL_EXTERNAL=$(echo -e "$EXTERNAL_APIS" | grep -c "🔍 函数名：")
          echo -e "\n【统计信息】"
          echo "能从.so调用的外部API总数：$TOTAL_EXTERNAL 个"
          echo -e "\n========================================"
          echo "📝 关键说明："
          echo "1. 仅以上函数会被编译到.so中，外部程序可直接调用；"
          echo "2. 参数/返回值需为C兼容类型（如*const c_char、c_int）；"
          echo "3. 未找到API请检查core/src/lib.rs的宏标记。"
          echo "========================================"

      # ===================== 补全截断的NDK安装步骤（关键修复） =====================
      - name: 正确安装NDK（空格分隔包）
        uses: android-actions/setup-android@v3
        with:
          accept-android-sdk-licenses: true
          packages: "ndk;${{ env.ANDROID_NDK_VERSION }} platforms;android-${{ env.ANDROID_API_LEVEL }}"

      - name: 验证NDK
        run: |
          NDK_PATH=$(find /usr/local/lib/android/sdk/ndk -maxdepth 1 -type d | grep ${{ env.ANDROID_NDK_VERSION }})
          if [ -z "$NDK_PATH" ]; then
            echo "❌ 未找到NDK"
            exit 1
          fi
          export ANDROID_NDK_ROOT=$NDK_PATH
          NDK_TOOLCHAIN_BIN="$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin"
          NDK_SYSROOT="$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/sysroot"
          echo "NDK_TOOLCHAIN_BIN=$NDK_TOOLCHAIN_BIN" >> $GITHUB_ENV
          echo "NDK_SYSROOT=$NDK_SYSROOT" >> $GITHUB_ENV
          if [ ! -f "$NDK_TOOLCHAIN_BIN/${{ env.TARGET_ARCH }}${{ env.ANDROID_API_LEVEL }}-clang" ]; then
            echo "❌ 编译器缺失"
            exit 1
          fi
          echo "✅ NDK验证通过"

      - name: 下载并编译OpenSSL
        run: |
          mkdir -p ${{ env.OPENSSL_SRC_DIR }} ${{ env.OPENSSL_INSTALL_DIR }}
          cd ${{ env.OPENSSL_SRC_DIR }}
          wget -q https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz
          tar -xvzf openssl-${{ env.OPENSSL_VERSION }}.tar.gz --strip-components=1
          export CC="${{ env.NDK_TOOLCHAIN_BIN }}/${{ env.TARGET_ARCH }}${{ env.ANDROID_API_LEVEL }}-clang"
          export CXX="${{ env.NDK_TOOLCHAIN_BIN }}/${{ env.TARGET_ARCH }}${{ env.ANDROID_API_LEVEL }}-clang++"
          export AR="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ar"
          export RANLIB="${{ env.NDK_TOOLCHAIN_BIN }}/llvm-ranlib"
          export LD="${{ env.NDK_TOOLCHAIN_BIN }}/ld.lld"
          export PATH="$NDK_TOOLCHAIN_BIN:$PATH"
          ./Configure linux-aarch64 no-shared no-asm no-zlib \
            --prefix=${{ env.OPENSSL_INSTALL_DIR }} \
            --sysroot=${{ env.NDK_SYSROOT }} \
            -fPIC -march=armv8-a \
            CC=$CC CXX=$CXX AR=$AR RANLIB=$RANLIB LD=$LD
          make -j$(nproc) V=1
          make install_sw && echo "✅ OpenSSL编译完成"

      - name: 配置Rust环境
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.85.0
          target: ${{ env.TARGET_ARCH }}

      - name: 安装cargo-ndk
        run: cargo install cargo-ndk --version=3.5.4 --locked

      - name: 修复工作区配置
        run: |
          # 清理根目录无效配置
          sed -i '/^\[lib\]$/,/^$/d' Cargo.toml
          echo "✅ 已清理根目录Cargo.toml"

          # 验证子包路径
          CORE_CARGO="${{ env.CORE_DIR }}/Cargo.toml"
          if [ ! -f "$CORE_CARGO" ]; then
            echo "❌ 子包目录不存在"
            ls -l */Cargo.toml
            exit 1
          fi

          # 添加cdylib配置（生成.so核心）
          if ! grep -q "crate-type = \[\"cdylib\"" "$CORE_CARGO"; then
            echo -e "\n[lib]\ncrate-type = [\"cdylib\"]" >> "$CORE_CARGO"
            echo "✅ 已添加cdylib配置"
          fi
          cat "$CORE_CARGO" | grep -A 2 "\[lib\]"

      - name: 编译核心子包（改用 --profile mobile）
        run: |
          cargo clean
          export OPENSSL_INCLUDE_DIR=${{ env.OPENSSL_INSTALL_DIR }}/include
          export OPENSSL_LIB_DIR=${{ env.OPENSSL_INSTALL_DIR }}/lib
          export OPENSSL_DIR=${{ env.OPENSSL_INSTALL_DIR }}
          export PKG_CONFIG_ALLOW_CROSS=1
          # 关键修改：把 --release 换成 --profile mobile
          cargo ndk -t ${{ env.TARGET_ARCH }} -o ${{ env.OUTPUT_DIR }} build \
            --package ${{ env.CORE_PACKAGE_NAME }} \
            --profile mobile
          echo "✅ 编译完成，产物目录："
          ls -l ${{ env.OUTPUT_DIR }}
          # 兜底收集所有.so文件，避免路径问题
          find target -name "lib*.so" -exec cp {} ${{ env.OUTPUT_DIR }}/ \;
          echo "✅ 最终产物列表："
          ls -l ${{ env.OUTPUT_DIR }}

      - name: 上传产物
        uses: actions/upload-artifact@v4
        with:
          name: lettalite-android-so-mobile
          path: ${{ env.OUTPUT_DIR }}/*.so
          retention-days: 14

      # 编译后验证.so导出API
      - name: 编译后验证.so外部API（确认可调用）
        run: |
          cd ${{ env.OUTPUT_DIR }}
          SO_FILE=$(ls -1 lib*.so | head -n 1)
          if [ -z "$SO_FILE" ]; then
            echo "❌ 未找到.so文件"
            exit 1
          fi
          echo -e "\n========================================"
          echo "🔍 编译后：.so实际可调用的外部API"
          echo "========================================"
          EXPORTED_FUNCS=$(nm -D $SO_FILE | grep "T " | grep -v "__" | awk '{print $3}')
          if [ -z "$EXPORTED_FUNCS" ]; then
            echo "⚠️  .so未导出任何函数！请检查源码API标记"
          else
            echo "能从.so调用的函数列表（共$(echo "$EXPORTED_FUNCS" | wc -l)个）："
            echo "$EXPORTED_FUNCS" | while read -r func; do
              echo "  - $func"
            done
          fi
          echo -e "\n💡 最终结论：以上函数可直接在外部程序中调用"
