name: lettalite作者方案：Rust安卓编译（profile mobile版）
on: [workflow_dispatch]
jobs:
  build-android:
    runs-on: ubuntu-latest
    env:
      ANDROID_NDK_VERSION: 27.3.13750724
      ANDROID_API_LEVEL: 24
      TARGET_ARCH: aarch64-linux-android
      OPENSSL_VERSION: 1.1.1w
      OPENSSL_SRC_DIR: ${{ github.workspace }}/openssl-src
      OPENSSL_INSTALL_DIR: ${{ github.workspace }}/openssl-install
      OUTPUT_DIR: ${{ github.workspace }}/target/android
      CORE_DIR: "core"  # 子包目录（正确）
      CORE_PACKAGE_NAME: "letta-core"  # 子包名（正确）

    steps:
      - name: 拉取letta-lite源码
        uses: actions/checkout@v4

      - name: 安装基础依赖
        run: |
          sudo apt-get update && sudo apt-get install -y \
            coreutils pkg-config make perl wget curl gcc cmake \
            libssl-dev zlib1g-dev

      # ===================== 修复：扫描源码提取外部API（仅能从.so调用的） =====================
      - name: 提取能从.so调用的外部API（编译前）
        run: |
          cd ${{ env.CORE_DIR }}  # 进入core子包目录
          echo -e "\n========================================"
          echo "📋 编译前：能从.so调用的外部API（仅暴露这些）"
          echo "========================================"
          echo "🔍 筛选规则：带 #[no_mangle] 或 extern \"C\" 标记的函数（外部可调用）"

          # 1. 扫描所有Rust文件，提取带外部API标记的函数（含注释、签名）
          # 逻辑：先找///注释，再找#[no_mangle]或extern "C"，再找函数签名
          EXTERNAL_APIS=$(grep -rniH --null -A 3 -B 3 -E '#\[no_mangle\]|extern "C"' src/ | \
            awk -v RS='\0' '{
              # 提取文件名
              match($0, /^([^:]+):/, fn);
              # 提取///注释
              if (match($0, /(/// .*\n)+/, docs)) {
                gsub(/\/\/\/ /, "", docs[0]);
                gsub(/\n+/, " ", docs[0]);
              } else {
                docs[0] = "无说明文档";
              }
              # 提取暴露标记（#[no_mangle] 或 extern "C"）
              if (match($0, /#\[no_mangle\]/)) {
                flag = "#[no_mangle]（宏自动标记）";
              } else if (match($0, /extern "C"/)) {
                flag = "extern \"C\"（手动标记）";
              }
              # 提取函数签名（fn 函数名(参数) -> 返回值）
              if (match($0, /fn ([a-zA-Z_][a-zA-Z0-9_]*)\(([^)]*)\) -> ([^;]*);?/, sig)) {
                func_name = sig[1];
                params = sig[2];
                ret_type = sig[3];
                # 格式化参数（去掉多余空格）
                gsub(/[ \t]+/, " ", params);
                # 输出结果
                printf "🔍 函数名：%s\n   所在文件：%s\n   参数：%s\n   返回值：%s\n   说明：%s\n   暴露标记：%s\n\n",
                  func_name, fn[1], params, ret_type, docs[0], flag;
              }
            }')

          # 2. 输出外部API列表
          if [ -z "$EXTERNAL_APIS" ]; then
            echo -e "\n⚠️  未找到任何外部API！请检查："
            echo "   - 是否用 export_letta_api!() 宏标记了要暴露的函数？"
            echo "   - 函数是否带 #[no_mangle] 或 extern \"C\" 标记？"
          else
            echo -e "\n【已标记的外部API（共$(echo "$EXTERNAL_APIS" | grep -c "🔍 函数名：")个）】"
            echo "$EXTERNAL_APIS"
          fi

          # 3. 统计信息
          TOTAL_EXTERNAL=$(echo "$EXTERNAL_APIS" | grep -c "🔍 函数名：")
          echo -e "\n【统计信息】"
          echo "能从.so调用的外部API总数：$TOTAL_EXTERNAL 个"
          echo -e "\n========================================"
          echo "📝 关键说明："
          echo "1. 只有以上函数会被编译到.so中，外部程序（Android/Godot）能直接调用；"
          echo "2. 参数/返回值必须是C兼容类型（如*const c_char、c_int），否则调用失败；"
          echo "3. 若未找到API，检查core/src/lib.rs中是否用 export_letta_api!() 标记了函数。"
          echo "========================================"

      # ===================== 原有步骤不变 =====================
      - name: 正确安装NDK（空格分隔包）
        uses: android-actions/setup-android@v3
        with:
          accept-android-sdk-licenses: true
        
